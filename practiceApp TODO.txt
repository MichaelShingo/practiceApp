- Sends data to AI to provide next practice recommendations
- Provides tutorial videos and recordings
- Can it provide notifications (text or email) about practice reminders, practice inspiration.
- boosted type of feature that times your practice sessions
- can you add notes about your practice to each piece? 
	
AI 
- Select a technique you want to work on from a list. 
- App sends to AI a list of pieces with that technique that you've already worked on. 
- AI will suggest further practice recommendations. 
- Allow chatting with the AI after this point? (but this could lead to abuse if people just use this as their personal portal) 
***************************
Next time you make a component, think about mobile-first design 

global filtering progression
1. filtered pieces changes, useEffect runs - setting global completion 
Category filtering progression
1. Filter applies, filtered pieces changes 
2. useeffect to set Filtered Piece IDS
3. filteredPieceIDS prop changes, use effect, setCount(0) - should masterySum be set here? 
- when you update teh filter, there's something that's just adding strings to the masterySum.....

DATA DASHBOARD
 	- like a github-type calendar that shows days that you completed pieces 
	- percentages of pieces completed at each difficulty level 
	- breakdown of composers you've worked on 
	- mastery level of each technique (calculated based on number of pieces you've completed that contain the technique and the mastery level of those pieces) 
	
	
	- number of pieces completed of each TYPE - Doughnut chart 
	
	
	- completed pieces by period - Doughnut chart OR Multi Series Pie? 
		- Or polar area where you show average mastery per category on the vertical axis 
SORTING 
- sort descending and ascending? 
- prevent duplicates based on (pieceID, userID) (BACKEND) 

DEPLOY
- It's basically a working app, can you deploy it so you at least have a react/django app? 

OPTIMIZATIONS
- run compareObj only once when search state updates 
- add more data so you know how it's going to run in reality 
- you'll want to optimize category, so you don't recalculate count every single time you load the app 

DESIGN / LOADING ANIMATIONS
- loading animation for the table and detail dialogue, on first load and on search 
- animation when clicking technique tag 
-  allow background color picker, store dark/light and color in local storage.

BUGS
- It's making a put request to update mastery when you add the piece (after clearing) , but it's not found in the database 



- WHAT HAPPENS IF YOU HAVE THE SAME PAGE OPEN ON MULTIPLE TABS/DEVICES? 


- Do you need to override rest_framework/serializers


- Violin Roadmap


{
    "email":"miko@gmail.com",
    "password":"johnson&&&",
    "first_name":"Miko",
    "last_name":"Single"
}



{
    "email":"mango@gmail.com",
    "password":"mian",
    "first_name":"Mango",
    "last_name":"Mian"
}

{
    "email":"dango@gmail.com",
    "password":"dango",
    "first_name":"Dango",
    "last_name":"Mian"
}


Superuser
mcrawford5376@gmail.com
1234


Type of Pieces
- Sonata
- Etude
- Scale
- Arpeggio
- Concerto
- Miniature
- Showpiece
- Exercise
- Suite


INSERT INTO pieces_technique (name, description, tutorial)
VALUES ('left hand articulation', 'placeholder', 'placeholder');


	
	
from rest_framework import serializers
from .models import Techniques

class TechniquesSerializer(serializers.ModelSerializer):
    class Meta:
        model = Techniques
        fields = '__all__'
		
		
		
		
OLD HANDLE CHECK FUNCTION 
const oldHandleCheckFunction= (e) => {
        console.log(e.target.name);
        try {
            e.target.classList.toggle('hide-checkmark');
            const checkedElement = e.target.previousElementSibling;
            checkedElement.classList.toggle('hide-checkmark');
            const pieceRow = checkedElement.parentNode.parentNode;
            const categoryID = pieceRow.getAttribute("categoryID").toString();
            const masteryLevel = pieceRow.querySelector('.mastery-number');

            const fraction = document.querySelector(`.fraction[categoryID="${categoryID}"]`);


            const fractionText = fraction.textContent;
            const slashIndex = fractionText.indexOf('/');
            console.log(fractionText, slashIndex);
            let numerator = parseInt(fractionText.substring(0, slashIndex));
            const denominator = fractionText.substring(slashIndex + 1, fractionText.length);
            // console.log(fractionText.indexOf('/'));
            const progressBar = document.querySelector(`.progress-bar[categoryID="${categoryID}"]`);
            console.log(progressBar);
            

            if (checkedElement.classList.contains('hide-checkmark')) { 
                // When you uncheck it decrement mastery
                console.log('unchecked');
                // masteryLevel.value = 0;
                numerator = numerator - 1;
                console.log(`numerator = ${numerator}`);
            } else {
                console.log('checked');
                // masteryLevel.value = 10;
                numerator = numerator + 1; 
            }
            let percentage = numerator / denominator * 100;
            console.log(`percentage = ${percentage}`);
            progressBar.style.width = `${percentage.toString()}%`;
            fraction.textContent = numerator.toString() + '/' + denominator.toString();
            // update database
        } catch (error){
            e.target.classList.toggle('hide-checkmark');
            console.log(error.message);
        }  
    }